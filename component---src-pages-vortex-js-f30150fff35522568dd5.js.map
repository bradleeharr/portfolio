{"version":3,"file":"component---src-pages-vortex-js-f30150fff35522568dd5.js","mappings":"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","sources":["webpack://gatsby-starter-default/./src/pages/vortex.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\n\r\nfunction Animation() {\r\n    const containerRef = useRef(null);\r\n      useEffect(() => {\r\n      console.log('Script Loaded');\r\n      const container = containerRef.current;\r\n      if (!container) return;\r\n  \r\n      const canvas = document.createElement('canvas');\r\n      const ctx = canvas.getContext('2d');\r\n      const titleDiv = document.createElement('div');\r\n      titleDiv.id = 'titleDiv';\r\n  \r\n      const totalCells = 100000;\r\n  \r\n      let canvasWidth = container.clientWidth;\r\n      let canvasHeight = container.clientHeight;\r\n      let cellSize = Math.sqrt((canvasWidth * canvasHeight) / totalCells);\r\n  \r\n  \r\n      let width = Math.floor(container.clientWidth / cellSize);\r\n      let height = Math.floor(container.clientHeight / cellSize);\r\n  \r\n      let grid = createGrid(width, height);\r\n      let nextGrid = createGrid(width, height);\r\n  \r\n      let waveAmplitude = 30000;\r\n      let columnsToUpdate = width;\r\n      let offset = 0;\r\n      let columnToUpdate = 0;\r\n      \r\n      let updateCounter = 0;\r\n      let stopPopTime = 2;\r\n      let resetTime = 250;\r\n      let dePopTime = 60;\r\n      let randAmt = 0.05;\r\n      // Set canvas size to match the container\r\n      canvas.width = container.clientWidth;\r\n      canvas.height = container.clientHeight;\r\n  \r\n      // Append canvas and title div to the container\r\n      container.appendChild(canvas);\r\n      container.appendChild(titleDiv);\r\n  \r\n      ctx.globalAlpha = 1.0;\r\n  \r\n      // Recalculate on resize\r\n      function resizeListener() {\r\n        canvasWidth = container.clientWidth;\r\n        canvasHeight = container.clientHeight;\r\n        canvas.width = canvasWidth;\r\n        canvas.height = canvasHeight;\r\n    \r\n        let newCellSize = Math.sqrt((canvasWidth * canvasHeight) / totalCells);\r\n        let newWidth = Math.floor(canvasWidth / newCellSize);\r\n        let newHeight = Math.floor(canvasHeight / newCellSize);\r\n    \r\n        let newGrid = createGrid(newWidth, newHeight);\r\n        let newNextGrid = createGrid(newWidth, newHeight);\r\n    \r\n        // Calculate offsets for centering the old grid onto the new one\r\n        let xOffset = Math.floor((newWidth - width) / 2);\r\n        let yOffset = Math.floor((newHeight - height) / 2);\r\n    \r\n        // Copy states from the old grid to the new grid with offset adjustments\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                if (y + yOffset >= 0 && y + yOffset < newHeight && x + xOffset >= 0 && x + xOffset < newWidth) {\r\n                    newGrid[y + yOffset][x + xOffset] = grid[y][x];\r\n                    newNextGrid[y + yOffset][x + xOffset] = nextGrid[y][x];\r\n                }\r\n            }\r\n        }\r\n    \r\n        // Update the grid, nextGrid, cellSize, width, and height to the new values\r\n        grid = newGrid;\r\n        nextGrid = newNextGrid;\r\n        cellSize = newCellSize;\r\n        width = newWidth;\r\n        height = newHeight; \r\n        updateCounter = 0;\r\n    }\r\n  \r\n  \r\n      window.addEventListener('resize', resizeListener);\r\n  \r\n      function createGrid(width, height) {\r\n          return new Array(height).fill(null).map(() => new Array(width).fill(false));\r\n      }\r\n  \r\n      function countNeighbors(grid, x, y) {\r\n          let count = 0;\r\n          for (let dx = -1; dx <= 1; dx++) {\r\n              for (let dy = -1; dy <= 1; dy++) {\r\n                  if (dx !== 0 || dy !== 0) {\r\n                      const nx = x + dx;\r\n                      const ny = y + dy;\r\n                      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n                          count += grid[ny][nx] ? 1 : 0;\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n          return count;\r\n      }\r\n  \r\n      function render(grid) {\r\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n          for (let y = 0; y < height; y++) {\r\n              waveAmplitude = (waveAmplitude + 1) % 1;\r\n              for (let x = 0; x < width; x++) {\r\n                  if (grid[y][x]) {\r\n                      if (Math.sin(2*x+y) > 0.5) {\r\n                          ctx.fillStyle = 'rgba(150, 75, 200, 0.9)';\r\n                      }\r\n                      else {\r\n                          ctx.fillStyle = 'rgba(75,150,200,0.9)';\r\n                      }\r\n                      ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\r\n                  }\r\n              }\r\n          }\r\n      }\r\n  \r\n      function update() {\r\n          ctx.fillStyle = 'rgba(255,1,1,1.0)'\r\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n          for (let i = 0; i < columnsToUpdate; i++) {\r\n              \r\n              for (let y = 0; y < height; y++) {\r\n                  offset = Math.sin(updateCounter) * waveAmplitude + Math.cos(updateCounter) * waveAmplitude + Math.sin(updateCounter*1.5) * waveAmplitude;\r\n                  columnToUpdate = (Math.round(updateCounter + offset) + i) % width;\r\n                  const neighbors = countNeighbors(grid, columnToUpdate, y);\r\n                  nextGrid[y][columnToUpdate] = ( neighbors > 6 || neighbors === 3 || neighbors === 2 && grid[y][columnToUpdate]);\r\n                  if (updateCounter < stopPopTime) {\r\n                      let random_num = Math.random();\r\n                      if (y > 0) nextGrid[y-1][columnToUpdate] |= (random_num < 0.04);\r\n                      if (columnToUpdate < columnsToUpdate) nextGrid[y][columnToUpdate+1] |= (random_num < 0.03);\r\n                      if (columnToUpdate+1 < columnsToUpdate) nextGrid[y][columnToUpdate+2] |= (random_num < 0.02);\r\n                      if (columnToUpdate+2 < columnsToUpdate) nextGrid[y][columnToUpdate+3] |= (random_num < 0.01);\r\n                      if (columnToUpdate+3 < columnsToUpdate) nextGrid[y][columnToUpdate+4] |= (random_num < 0.5);\r\n                  }\r\n                  if (updateCounter > resetTime - dePopTime) {\r\n                      let random_num = Math.random();\r\n                      nextGrid[y][columnToUpdate] = ((neighbors === 1 && Math.random() > 0.98) || neighbors === 4 || neighbors === 3 || neighbors === 2) && Math.random() > 0.5375;\r\n                  }               \r\n              }\r\n              // Copy the updated column from nextGrid to grid\r\n              for (let y = 0; y < height; y++) {\r\n                  grid[y][columnToUpdate] = nextGrid[y][columnToUpdate];\r\n              }\r\n          }\r\n  \r\n          if ((updateCounter > resetTime && Math.random() > 0.90) || (updateCounter > resetTime*1.5 && Math.random() > 0.4)) {\r\n              updateCounter = stopPopTime;\r\n          }\r\n  \r\n          render(grid);\r\n          updateCounter++;\r\n      }\r\n  \r\n      // Initialize the grid with random values\r\n      grid.forEach(row => {\r\n          row.forEach((cell, index) => {\r\n              row[index] = Math.random() + Math.random() < randAmt;\r\n          });\r\n      });\r\n  \r\n      // Start the animation loop\r\n      // Start the animation loop with initial speed\r\n      let start = performance.now();\r\n      let delay = 20; // Delay between frames in milliseconds\r\n  \r\n      function startAnimation(timestamp) {\r\n          if (timestamp - start >= delay) {\r\n              update();\r\n              start = timestamp;\r\n          }\r\n  \r\n          requestAnimationFrame(startAnimation);\r\n      }\r\n  \r\n      startAnimation(performance.now());\r\n  \r\n      // Optional: You might want to clean up the animation if the component is unmounted\r\n      return () => {\r\n          window.removeEventListener('resize', resizeListener);\r\n        };\r\n      }, []); // Empty dependency array means this useEffect runs once when the component mounts\r\n    \r\n      return <div style={{width: '100vw', height: '100vh'}} ref={containerRef}></div>;\r\n  }\r\n\r\nexport default Animation;\r\n\r\n"],"names":["containerRef","useRef","useEffect","console","log","container","current","canvas","document","createElement","ctx","getContext","titleDiv","id","totalCells","canvasWidth","clientWidth","canvasHeight","clientHeight","cellSize","Math","sqrt","width","floor","height","grid","createGrid","nextGrid","waveAmplitude","columnsToUpdate","offset","columnToUpdate","updateCounter","stopPopTime","resetTime","dePopTime","resizeListener","newCellSize","newWidth","newHeight","newGrid","newNextGrid","xOffset","yOffset","y","x","Array","fill","map","countNeighbors","count","dx","dy","nx","ny","update","fillStyle","fillRect","i","sin","cos","round","neighbors","random_num","random","clearRect","render","appendChild","globalAlpha","window","addEventListener","forEach","row","cell","index","start","performance","now","startAnimation","timestamp","requestAnimationFrame","removeEventListener","React","style","ref"],"sourceRoot":""}